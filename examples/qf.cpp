//$file${src::qf::qep_hsm.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qep_hsm.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qep_hsm.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

//============================================================================
//! @cond INTERNAL

// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_MODULE("qep_hsm")

// immutable events corresponding to the reserved signals.
static QP::QEvt const l_reservedEvt_[4] {
    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_EMPTY_SIG)),
    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_ENTRY_SIG)),
    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_EXIT_SIG)),
    QP::QEvt(static_cast<QP::QSignal>(QP::QHsm::Q_INIT_SIG))
};

} // unnamed namespace

// helper macro to handle reserved event in an QHsm
#define QHSM_RESERVED_EVT_(state_, sig_) \
    ((*(state_))(this, &l_reservedEvt_[(sig_)]))

// helper macro to trace state entry
#define QS_STATE_ENTRY_(state_, qs_id_)         \
    QS_CRIT_ENTRY();                            \
    QS_MEM_SYS();                               \
    QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, (qs_id_)) \
        QS_OBJ_PRE_(this);                      \
        QS_FUN_PRE_(state_);                    \
    QS_END_PRE_()                               \
    QS_MEM_APP();                               \
    QS_CRIT_EXIT()

// helper macro to trace state exit
#define QS_STATE_EXIT_(state_, qs_id_)          \
    QS_CRIT_ENTRY();                            \
    QS_MEM_SYS();                               \
    QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, (qs_id_))  \
        QS_OBJ_PRE_(this);                      \
        QS_FUN_PRE_(state_);                    \
    QS_END_PRE_()                               \
    QS_MEM_APP();                               \
    QS_CRIT_EXIT()

//! @endcond
//============================================================================

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QEP::versionStr[]} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

} // namespace QP
//$enddef${QEP::versionStr[]} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QEP::QHsm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QEP::QHsm} ...............................................................

//${QEP::QHsm::QHsm} .........................................................
QHsm::QHsm(QStateHandler const initial) noexcept
: QAsm()
{
    m_state.fun = Q_STATE_CAST(&top);
    m_temp.fun  = initial;
}

//${QEP::QHsm::init} .........................................................
void QHsm::init(
    void const * const e,
    std::uint_fast8_t const qs_id)
{
    QF_CRIT_STAT

    #ifdef Q_SPY
    QS_CRIT_ENTRY();
    QS_MEM_SYS();
    if ((QS::priv_.flags & 0x01U) == 0U) {
        QS::priv_.flags |= 0x01U;
        QS_FUN_DICTIONARY(&QP::QHsm::top);
    }
    QS_MEM_APP();
    QS_CRIT_EXIT();
    #else
    Q_UNUSED_PAR(qs_id);
    #endif

    QStateHandler t = m_state.fun;

    QF_CRIT_ENTRY();
    Q_REQUIRE_INCRIT(200, (m_temp.fun != nullptr)
                      && (t == Q_STATE_CAST(&top)));
    QF_CRIT_EXIT();

    // execute the top-most initial tran.
    QState r = (*m_temp.fun)(this, Q_EVT_CAST(QEvt));

    QF_CRIT_ENTRY();
    // the top-most initial tran. must be taken
    Q_ASSERT_INCRIT(210, r == Q_RET_TRAN);

    QS_MEM_SYS();
    QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qs_id)
        QS_OBJ_PRE_(this);         // this state machine object
        QS_FUN_PRE_(t);            // the source state
        QS_FUN_PRE_(m_temp.fun);   // the target of the initial tran.
    QS_END_PRE_()
    QS_MEM_APP();

    QF_CRIT_EXIT();

    // drill down into the state hierarchy with initial transitions...
    do {
        QStateHandler path[MAX_NEST_DEPTH_]; // tran entry path array
        std::int_fast8_t ip = 0; // entry path index

        path[0] = m_temp.fun;
        static_cast<void>(QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
        while (m_temp.fun != t) {
            ++ip;
            QF_CRIT_ENTRY();
            Q_ASSERT_INCRIT(220, ip < MAX_NEST_DEPTH_);
            QF_CRIT_EXIT();
            path[ip] = m_temp.fun;
            static_cast<void>(QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
        }
        m_temp.fun = path[0];

        // retrace the entry path in reverse (desired) order...
        do {
            // enter path[ip]
            if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
                == Q_RET_HANDLED)
            {
                QS_STATE_ENTRY_(path[ip], qs_id);
            }
            --ip;
        } while (ip >= 0);

        t = path[0]; // current state becomes the new source

        r = QHSM_RESERVED_EVT_(t, Q_INIT_SIG); // execute initial tran.

    #ifdef Q_SPY
        if (r == Q_RET_TRAN) {
            QS_CRIT_ENTRY();
            QS_MEM_SYS();
            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qs_id)
                QS_OBJ_PRE_(this);         // this state machine object
                QS_FUN_PRE_(t);            // the source state
                QS_FUN_PRE_(m_temp.fun);   // the target of the initial tran.
            QS_END_PRE_()
            QS_MEM_APP();
            QS_CRIT_EXIT();
        }
    #endif // Q_SPY

    } while (r == Q_RET_TRAN);

    QS_CRIT_ENTRY();
    QS_MEM_SYS();
    QS_BEGIN_PRE_(QS_QEP_INIT_TRAN, qs_id)
        QS_TIME_PRE_();    // time stamp
        QS_OBJ_PRE_(this); // this state machine object
        QS_FUN_PRE_(t);    // the new active state
    QS_END_PRE_()
    QS_MEM_APP();
    QS_CRIT_EXIT();

    m_state.fun = t;   // change the current active state
    #ifndef Q_UNSAFE
    m_temp.uint = ~m_state.uint;
    #endif
}

//${QEP::QHsm::dispatch} .....................................................
void QHsm::dispatch(
    QEvt const * const e,
    std::uint_fast8_t const qs_id)
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QStateHandler s = m_state.fun;
    QStateHandler t = s;
    QF_CRIT_STAT

    QF_CRIT_ENTRY();
    Q_REQUIRE_INCRIT(300, (s != Q_STATE_CAST(0))
        && (m_state.uint == static_cast<std::uintptr_t>(~m_temp.uint)));
    Q_REQUIRE_INCRIT(302, QEvt::verify_(e));

    QS_MEM_SYS();
    QS_BEGIN_PRE_(QS_QEP_DISPATCH, qs_id)
        QS_TIME_PRE_();      // time stamp
        QS_SIG_PRE_(e->sig); // the signal of the event
        QS_OBJ_PRE_(this);   // this state machine object
        QS_FUN_PRE_(s);      // the current state
    QS_END_PRE_()
    QS_MEM_APP();

    QF_CRIT_EXIT();

    // process the event hierarchically...
    QState r;
    m_temp.fun = s;
    do {
        s = m_temp.fun;
        r = (*s)(this, e); // invoke state handler s

        if (r == Q_RET_UNHANDLED) { // unhandled due to a guard?

            QS_CRIT_ENTRY();
            QS_MEM_SYS();
            QS_BEGIN_PRE_(QS_QEP_UNHANDLED, qs_id)
                QS_SIG_PRE_(e->sig); // the signal of the event
                QS_OBJ_PRE_(this);   // this state machine object
                QS_FUN_PRE_(s);      // the current state
            QS_END_PRE_()
            QS_MEM_APP();
            QS_CRIT_EXIT();

            r = QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG); // superstate of s
        }
    } while (r == Q_RET_SUPER);

    if (r >= Q_RET_TRAN) { // regular tran. taken?
        QStateHandler path[MAX_NEST_DEPTH_];

        path[0] = m_temp.fun; // tran. target
        path[1] = t; // current state
        path[2] = s; // tran. source

        // exit current state to tran. source s...
        for (; t != s; t = m_temp.fun) {
            // exit from t
            if (QHSM_RESERVED_EVT_(t, Q_EXIT_SIG) == Q_RET_HANDLED) {
                QS_STATE_EXIT_(t, qs_id);
                // find superstate of t
                static_cast<void>(QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG));
            }
        }
        std::int_fast8_t ip = hsm_tran(path, qs_id); // take the tran.

    #ifdef Q_SPY
        if (r == Q_RET_TRAN_HIST) {
            QS_CRIT_ENTRY();
            QS_MEM_SYS();
            QS_BEGIN_PRE_(QS_QEP_TRAN_HIST, qs_id)
                QS_OBJ_PRE_(this);    // this state machine object
                QS_FUN_PRE_(t);       // the source of the transition
                QS_FUN_PRE_(path[0]); // the target of the tran. to history
            QS_END_PRE_()
            QS_MEM_APP();
            QS_CRIT_EXIT();
        }
    #endif // Q_SPY

        // execute state entry actions in the desired order...
        for (; ip >= 0; --ip) {
            // enter path[ip]
            if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
                == Q_RET_HANDLED)
            {
                QS_STATE_ENTRY_(path[ip], qs_id);
            }
        }
        t = path[0];    // stick the target into register
        m_temp.fun = t; // update the next state

        // drill into the target hierarchy...
        while (QHSM_RESERVED_EVT_(t, Q_INIT_SIG) == Q_RET_TRAN) {

            QS_CRIT_ENTRY();
            QS_MEM_SYS();
            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qs_id)
                QS_OBJ_PRE_(this);         // this state machine object
                QS_FUN_PRE_(t);            // the source (pseudo)state
                QS_FUN_PRE_(m_temp.fun);   // the target of the tran.
            QS_END_PRE_()
            QS_MEM_APP();
            QS_CRIT_EXIT();

            ip = 0;
            path[0] = m_temp.fun;

            // find superstate
            static_cast<void>(QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));

            while (m_temp.fun != t) {
                ++ip;
                path[ip] = m_temp.fun;
                // find superstate
                static_cast<void>(
                    QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG));
            }
            m_temp.fun = path[0];

            // entry path must not overflow
            QF_CRIT_ENTRY();
            Q_ASSERT_INCRIT(410, ip < MAX_NEST_DEPTH_);
            QF_CRIT_EXIT();

            // retrace the entry path in reverse (correct) order...
            do {
                // enter path[ip]
                if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
                    == Q_RET_HANDLED)
                {
                    QS_STATE_ENTRY_(path[ip], qs_id);
                }
                --ip;
            } while (ip >= 0);

            t = path[0]; // current state becomes the new source
        }

        QS_CRIT_ENTRY();
        QS_MEM_SYS();
        QS_BEGIN_PRE_(QS_QEP_TRAN, qs_id)
            QS_TIME_PRE_();      // time stamp
            QS_SIG_PRE_(e->sig); // the signal of the event
            QS_OBJ_PRE_(this);   // this state machine object
            QS_FUN_PRE_(s);      // the source of the tran.
            QS_FUN_PRE_(t);      // the new active state
        QS_END_PRE_()
        QS_MEM_APP();
        QS_CRIT_EXIT();
    }

    #ifdef Q_SPY
    else if (r == Q_RET_HANDLED) {
        QS_CRIT_ENTRY();
        QS_MEM_SYS();
        QS_BEGIN_PRE_(QS_QEP_INTERN_TRAN, qs_id)
            QS_TIME_PRE_();      // time stamp
            QS_SIG_PRE_(e->sig); // the signal of the event
            QS_OBJ_PRE_(this);   // this state machine object
            QS_FUN_PRE_(s);      // the source state
        QS_END_PRE_()
        QS_MEM_APP();
        QS_CRIT_EXIT();
    }
    else {
        QS_CRIT_ENTRY();
        QS_MEM_SYS();
        QS_BEGIN_PRE_(QS_QEP_IGNORED, qs_id)
            QS_TIME_PRE_();      // time stamp
            QS_SIG_PRE_(e->sig); // the signal of the event
            QS_OBJ_PRE_(this);   // this state machine object
            QS_FUN_PRE_(m_state.fun); // the current state
        QS_END_PRE_()
        QS_MEM_APP();
        QS_CRIT_EXIT();
    }
    #endif // Q_SPY

    m_state.fun = t; // change the current active state
    #ifndef Q_UNSAFE
    m_temp.uint = ~m_state.uint;
    #endif
}

//${QEP::QHsm::isIn} .........................................................
bool QHsm::isIn(QStateHandler const state) noexcept {
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    Q_REQUIRE_INCRIT(602, m_state.uint
                      == static_cast<std::uintptr_t>(~m_temp.uint));
    QF_CRIT_EXIT();

    bool inState = false; // assume that this HSM is not in 'state'

    // scan the state hierarchy bottom-up
    QState r;
    do {
        // do the states match?
        if (m_temp.fun == state) {
            inState = true;    // 'true' means that match found
            r = Q_RET_IGNORED; // cause breaking out of the loop
        }
        else {
            r = QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG);
        }
    } while (r != Q_RET_IGNORED); // QHsm::top() state not reached

    #ifndef Q_UNSAFE
    m_temp.uint = ~m_state.uint;
    #endif

    return inState; // return the status
}

//${QEP::QHsm::childState} ...................................................
QStateHandler QHsm::childState(QStateHandler const parent) noexcept {
    QStateHandler child = m_state.fun; // start with the current state
    bool isFound = false; // start with the child not found

    // establish stable state configuration
    m_temp.fun = child;
    QState r;
    do {
        // is this the parent of the current child?
        if (m_temp.fun == parent) {
            isFound = true; // child is found
            r = Q_RET_IGNORED; // break out of the loop
        }
        else {
            child = m_temp.fun;
            r = QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG);
        }
    } while (r != Q_RET_IGNORED); // QHsm::top() state not reached

    #ifndef Q_UNSAFE
    m_temp.uint = ~m_state.uint;
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    Q_ASSERT_INCRIT(890, isFound);
    QF_CRIT_EXIT();

    return child; // return the child
}

//${QEP::QHsm::hsm_tran} .....................................................
std::int_fast8_t QHsm::hsm_tran(
    QStateHandler (&path)[MAX_NEST_DEPTH_],
    std::uint_fast8_t const qs_id)
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    std::int_fast8_t ip = -1; // tran. entry path index
    QStateHandler t = path[0];
    QStateHandler const s = path[2];
    QF_CRIT_STAT

    // (a) check source==target (tran. to self)...
    if (s == t) {
        // exit source s
        if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
            QS_STATE_EXIT_(s, qs_id);
        }
        ip = 0; // enter the target
    }
    else {
        // find superstate of target
        static_cast<void>(QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG));

        t = m_temp.fun;

        // (b) check source==target->super...
        if (s == t) {
            ip = 0; // enter the target
        }
        else {
            // find superstate of src
            static_cast<void>(QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG));

            // (c) check source->super==target->super...
            if (m_temp.fun == t) {
                // exit source s
                if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
                    QS_STATE_EXIT_(s, qs_id);
                }
                ip = 0; // enter the target
            }
            else {
                // (d) check source->super==target...
                if (m_temp.fun == path[0]) {
                    // exit source s
                    if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
                        QS_STATE_EXIT_(s, qs_id);
                    }
                }
                else {
                    // (e) check rest of source==target->super->super..
                    // and store the entry path along the way
                    std::int_fast8_t iq = 0; // indicate that LCA was found
                    ip = 1; // enter target and its superstate
                    path[1] = t;    // save the superstate of target
                    t = m_temp.fun; // save source->super

                    // find target->super->super...
                    QState r = QHSM_RESERVED_EVT_(path[1], Q_EMPTY_SIG);
                    while (r == Q_RET_SUPER) {
                        ++ip;
                        path[ip] = m_temp.fun; // store the entry path
                        if (m_temp.fun == s) { // is it the source?
                            iq = 1; // indicate that the LCA found

                            // entry path must not overflow
                            QF_CRIT_ENTRY();
                            Q_ASSERT_INCRIT(510, ip < MAX_NEST_DEPTH_);
                            QF_CRIT_EXIT();
                            --ip; // do not enter the source
                            r = Q_RET_HANDLED; // terminate the loop
                        }
                        else { // it is not the source, keep going up
                            r = QHSM_RESERVED_EVT_(m_temp.fun, Q_EMPTY_SIG);
                        }
                    }

                    // the LCA not found yet?
                    if (iq == 0) {
                        // entry path must not overflow
                        QF_CRIT_ENTRY();
                        Q_ASSERT_INCRIT(520, ip < MAX_NEST_DEPTH_);
                        QF_CRIT_EXIT();

                        // exit source s
                        if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG)
                            == Q_RET_HANDLED)
                        {
                            QS_STATE_EXIT_(s, qs_id);
                        }

                        // (f) check the rest of source->super
                        //                  == target->super->super...
                        iq = ip;
                        r = Q_RET_IGNORED; // indicate that the LCA NOT found
                        do {
                            if (t == path[iq]) { // is this the LCA?
                                r = Q_RET_HANDLED; // indicate the LCA found
                                ip = iq - 1; // do not enter the LCA
                                iq = -1; // cause termination of the loop
                            }
                            else {
                                --iq; // try lower superstate of target
                            }
                        } while (iq >= 0);

                        // the LCA not found yet?
                        if (r != Q_RET_HANDLED) {
                            // (g) check each source->super->...
                            // for each target->super...
                            r = Q_RET_IGNORED; // keep looping
                            do {
                                // exit from t
                                if (QHSM_RESERVED_EVT_(t, Q_EXIT_SIG)
                                    == Q_RET_HANDLED)
                                {
                                    QS_STATE_EXIT_(t, qs_id);
                                    // find superstate of t
                                    static_cast<void>(
                                        QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG));
                                }
                                t = m_temp.fun; // set to super of t
                                iq = ip;
                                do {
                                    // is this the LCA?
                                    if (t == path[iq]) {
                                        ip = iq - 1; // do not enter the LCA
                                        iq = -1;     // break out of inner loop
                                        r = Q_RET_HANDLED; // break outer loop
                                    }
                                    else {
                                        --iq;
                                    }
                                } while (iq >= 0);
                            } while (r != Q_RET_HANDLED);
                        }
                    }
                }
            }
        }
    }
    return ip;
}

} // namespace QP
//$enddef${QEP::QHsm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$file${src::qf::qep_msm.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qep_msm.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qep_msm.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

//============================================================================
//! @cond INTERNAL

// unnamed namespace for local definitions with internal linkage
namespace {

Q_DEFINE_THIS_MODULE("qep_msm")

// top-state object for QMsm-style state machines
QP::QMState const l_msm_top_s = {
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr
};

static constexpr std::int_fast8_t MAX_ENTRY_DEPTH_ {4};

} // unnamed namespace

//! @endcond
//============================================================================

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QEP::QMsm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QEP::QMsm} ...............................................................

//${QEP::QMsm::QMsm} .........................................................
QMsm::QMsm(QStateHandler const initial) noexcept
  : QAsm()
{
    m_state.obj = &l_msm_top_s; // the current state (top)
    m_temp.fun  = initial;      // the initial tran. handler
}

//${QEP::QMsm::init} .........................................................
void QMsm::init(
    void const * const e,
    std::uint_fast8_t const qs_id)
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    Q_REQUIRE_INCRIT(200, (m_temp.fun != nullptr)
                      && (m_state.obj == &l_msm_top_s));
    QF_CRIT_EXIT();

    // execute the top-most initial tran.
    QState r = (*m_temp.fun)(this, Q_EVT_CAST(QEvt));

    QF_CRIT_ENTRY();
    // the top-most initial tran. must be taken
    Q_ASSERT_INCRIT(210, r == Q_RET_TRAN_INIT);

    QS_MEM_SYS();
    QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qs_id)
        QS_OBJ_PRE_(this);  // this state machine object
        QS_FUN_PRE_(m_state.obj->stateHandler);          // source state
        QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target state
    QS_END_PRE_()
    QS_MEM_APP();

    QF_CRIT_EXIT();

    // set state to the last tran. target
    m_state.obj = m_temp.tatbl->target;

    // drill down into the state hierarchy with initial transitions...
    do {
        // execute the tran. table
        r = execTatbl_(m_temp.tatbl, qs_id);
    } while (r >= Q_RET_TRAN_INIT);

    QS_CRIT_ENTRY();
    QS_MEM_SYS();
    QS_BEGIN_PRE_(QS_QEP_INIT_TRAN, qs_id)
        QS_TIME_PRE_();    // time stamp
        QS_OBJ_PRE_(this); // this state machine object
        QS_FUN_PRE_(m_state.obj->stateHandler); // the new current state
    QS_END_PRE_()
    QS_MEM_APP();
    QS_CRIT_EXIT();

    #ifndef Q_UNSAFE
    m_temp.uint = ~m_state.uint;
    #endif
}

//${QEP::QMsm::dispatch} .....................................................
void QMsm::dispatch(
    QEvt const * const e,
    std::uint_fast8_t const qs_id)
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QMState const *s = m_state.obj; // store the current state
    QMState const *t = s;

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    Q_REQUIRE_INCRIT(300, (s != nullptr)
        && (m_state.uint == static_cast<std::uintptr_t>(~m_temp.uint)));
    Q_REQUIRE_INCRIT(302, QEvt::verify_(e));

    QS_MEM_SYS();
    QS_BEGIN_PRE_(QS_QEP_DISPATCH, qs_id)
        QS_TIME_PRE_();               // time stamp
        QS_SIG_PRE_(e->sig);          // the signal of the event
        QS_OBJ_PRE_(this);            // this state machine object
        QS_FUN_PRE_(s->stateHandler); // the current state handler
    QS_END_PRE_()
    QS_MEM_APP();

    QF_CRIT_EXIT();

    // scan the state hierarchy up to the top state...
    QState r;
    do {
        r = (*t->stateHandler)(this, e); // call state handler function

        // event handled? (the most frequent case)
        if (r >= Q_RET_HANDLED) {
            break; // done scanning the state hierarchy
        }
        // event unhandled and passed to the superstate?
        else if (r == Q_RET_SUPER) {
            t = t->superstate; // advance to the superstate
        }
        // event unhandled and passed to a submachine superstate?
        else if (r == Q_RET_SUPER_SUB) {
            t = m_temp.obj; // current host state of the submachie
        }
        else { // event unhandled due to a guard?
            QF_CRIT_ENTRY();
            // event must be unhandled due to a guard evaluating to 'false'
            Q_ASSERT_INCRIT(310, r == Q_RET_UNHANDLED);

            QS_MEM_SYS();
            QS_BEGIN_PRE_(QS_QEP_UNHANDLED, qs_id)
                QS_SIG_PRE_(e->sig);  // the signal of the event
                QS_OBJ_PRE_(this);    // this state machine object
                QS_FUN_PRE_(t->stateHandler); // the current state
            QS_END_PRE_()
            QS_MEM_APP();

            QF_CRIT_EXIT();

            t = t->superstate; // advance to the superstate
        }
    } while (t != nullptr);

    if (r >= Q_RET_TRAN) { // any kind of tran. taken?
    #ifdef Q_SPY
        QMState const * const ts = t; // transition source for QS tracing

        QF_CRIT_ENTRY();
        // the tran. source state must not be nullptr
        Q_ASSERT_INCRIT(320, ts != nullptr);
        QF_CRIT_EXIT();
    #endif // Q_SPY

        do {
            // save the tran-action table before it gets clobbered
            QMTranActTable const * const tatbl = m_temp.tatbl;
            QAsmAttr tmp; // temporary to save intermediate values

            // was TRAN, TRAN_INIT, or TRAN_EP taken?
            if (r <= Q_RET_TRAN_EP) {
                m_temp.obj = nullptr; // clear
                exitToTranSource_(s, t, qs_id);
                r = execTatbl_(tatbl, qs_id);
                s = m_state.obj;
            }
            // was a tran. segment to history taken?
            else if (r == Q_RET_TRAN_HIST) {
                tmp.obj = m_state.obj; // save history
                m_state.obj = s; // restore the original state
                exitToTranSource_(s, t, qs_id);
                static_cast<void>(execTatbl_(tatbl, qs_id));
                r = enterHistory_(tmp.obj, qs_id);
                s = m_state.obj;
            }
            else {
                QF_CRIT_ENTRY();
                // must be tran. to exit point
                Q_ASSERT_INCRIT(340, r == Q_RET_TRAN_XP);
                QF_CRIT_EXIT();

                tmp.act = m_state.act; // save XP action
                m_state.obj = s; // restore the original state
                r = (*tmp.act)(this); // execute the XP action
                if (r == Q_RET_TRAN) { // XP -> TRAN ?
    #ifdef Q_SPY
                    tmp.tatbl = m_temp.tatbl; // save m_temp
    #endif // Q_SPY
                    exitToTranSource_(s, t, qs_id);
                    // take the tran-to-XP segment inside submachine
                    static_cast<void>(execTatbl_(tatbl, qs_id));
                    s = m_state.obj;
    #ifdef Q_SPY
                    m_temp.tatbl = tmp.tatbl; // restore m_temp
    #endif // Q_SPY
                }
                else if (r == Q_RET_TRAN_HIST) { // XP -> HIST ?
                    tmp.obj = m_state.obj; // save the history
                    m_state.obj = s; // restore the original state
    #ifdef Q_SPY
                    s = m_temp.obj; // save m_temp
    #endif // Q_SPY
                    exitToTranSource_(m_state.obj, t, qs_id);
                    // take the tran-to-XP segment inside submachine
                    static_cast<void>(execTatbl_(tatbl, qs_id));
    #ifdef Q_SPY
                    m_temp.obj = s; // restore me->temp
    #endif // Q_SPY
                    s = m_state.obj;
                    m_state.obj = tmp.obj; // restore the history
                }
                else {
                    QF_CRIT_ENTRY();
                    // TRAN_XP must NOT be followed by any other tran type
                    Q_ASSERT_INCRIT(330, r < Q_RET_TRAN);
                    QF_CRIT_EXIT();
                }
            }

            t = s; // set target to the current state

        } while (r >= Q_RET_TRAN);

        QS_CRIT_ENTRY();
        QS_MEM_SYS();
        QS_BEGIN_PRE_(QS_QEP_TRAN, qs_id)
            QS_TIME_PRE_();                 // time stamp
            QS_SIG_PRE_(e->sig);            // the signal of the event
            QS_OBJ_PRE_(this);              // this state machine object
            QS_FUN_PRE_(ts->stateHandler);  // the tran. source
            QS_FUN_PRE_(s->stateHandler);   // the new active state
        QS_END_PRE_()
        QS_MEM_APP();
        QS_CRIT_EXIT();
    }

    #ifdef Q_SPY
    // was the event handled?
    else if (r == Q_RET_HANDLED) {
        QF_CRIT_ENTRY();
        // internal tran. source can't be nullptr
        Q_ASSERT_INCRIT(340, t != nullptr);

        QS_MEM_SYS();
        QS_BEGIN_PRE_(QS_QEP_INTERN_TRAN, qs_id)
            QS_TIME_PRE_();                 // time stamp
            QS_SIG_PRE_(e->sig);            // the signal of the event
            QS_OBJ_PRE_(this);              // this state machine object
            QS_FUN_PRE_(t->stateHandler);   // the source state
        QS_END_PRE_()
        QS_MEM_APP();

        QF_CRIT_EXIT();
    }
    // event bubbled to the 'top' state?
    else if (t == nullptr) {
        QS_CRIT_ENTRY();
        QS_MEM_SYS();
        QS_BEGIN_PRE_(QS_QEP_IGNORED, qs_id)
            QS_TIME_PRE_();                 // time stamp
            QS_SIG_PRE_(e->sig);            // the signal of the event
            QS_OBJ_PRE_(this);              // this state machine object
            QS_FUN_PRE_(s->stateHandler);   // the current state
        QS_END_PRE_()
        QS_MEM_APP();
        QS_CRIT_EXIT();
    }
    #endif // Q_SPY
    else {
        // empty
    }

    #ifndef Q_UNSAFE
    m_temp.uint = ~m_state.uint;
    #endif
}

//${QEP::QMsm::isInState} ....................................................
bool QMsm::isInState(QMState const * const stateObj) const noexcept {
    bool inState = false; // assume that this MSM is not in 'state'

    for (QMState const *s = m_state.obj;
         s != nullptr;
         s = s->superstate)
    {
        if (s == stateObj) {
            inState = true; // match found, return 'true'
            break;
        }
    }
    return inState;
}

//${QEP::QMsm::childStateObj} ................................................
QMState const * QMsm::childStateObj(QMState const * const parent) const noexcept {
    QMState const *child = m_state.obj;
    bool isFound = false; // start with the child not found
    QMState const *s;

    for (s = m_state.obj; s != nullptr; s = s->superstate) {
        if (s == parent) {
            isFound = true; // child is found
            break;
        }
        else {
            child = s;
        }
    }
    if (!isFound) { // still not found?
        for (s = m_temp.obj; s != nullptr; s = s->superstate) {
            if (s == parent) {
                isFound = true; // child is found
                break;
            }
            else {
                child = s;
            }
        }
    }

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    Q_ASSERT_INCRIT(890, isFound);
    QF_CRIT_EXIT();

    return child; // return the child
}

//${QEP::QMsm::execTatbl_} ...................................................
QState QMsm::execTatbl_(
    QMTranActTable const * const tatbl,
    std::uint_fast8_t const qs_id)
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    // precondition:
    // - the tran-action table pointer must not be NULL
    Q_REQUIRE_INCRIT(400, tatbl != nullptr);
    QF_CRIT_EXIT();

    QState r = Q_RET_NULL;
    for (QActionHandler const *a = &tatbl->act[0]; *a != nullptr; ++a) {
        r = (*(*a))(this); // call the action through the 'a' pointer
    #ifdef Q_SPY
        QS_CRIT_ENTRY();
        QS_MEM_SYS();
        if (r == Q_RET_ENTRY) {
            QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, qs_id)
                QS_OBJ_PRE_(this); // this state machine object
                QS_FUN_PRE_(m_temp.obj->stateHandler); // entered state
            QS_END_PRE_()
        }
        else if (r == Q_RET_EXIT) {
            QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, qs_id)
                QS_OBJ_PRE_(this); // this state machine object
                QS_FUN_PRE_(m_temp.obj->stateHandler); // exited state
            QS_END_PRE_()
        }
        else if (r == Q_RET_TRAN_INIT) {
            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qs_id)
                QS_OBJ_PRE_(this); // this state machine object
                QS_FUN_PRE_(tatbl->target->stateHandler);        // source
                QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target
            QS_END_PRE_()
        }
        else if (r == Q_RET_TRAN_EP) {
            QS_BEGIN_PRE_(QS_QEP_TRAN_EP, qs_id)
                QS_OBJ_PRE_(this); // this state machine object
                QS_FUN_PRE_(tatbl->target->stateHandler);        // source
                QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target
            QS_END_PRE_()
        }
        else if (r == Q_RET_TRAN_XP) {
            QS_BEGIN_PRE_(QS_QEP_TRAN_XP, qs_id)
                QS_OBJ_PRE_(this); // this state machine object
                QS_FUN_PRE_(tatbl->target->stateHandler);        // source
                QS_FUN_PRE_(m_temp.tatbl->target->stateHandler); // target
            QS_END_PRE_()
        }
        else {
            // empty
        }
        QS_MEM_APP();
        QS_CRIT_EXIT();
    #endif // Q_SPY
    }

    m_state.obj = (r >= Q_RET_TRAN)
        ? m_temp.tatbl->target
        : tatbl->target;
    return r;
}

//${QEP::QMsm::exitToTranSource_} ............................................
void QMsm::exitToTranSource_(
    QMState const * const cs,
    QMState const * const ts,
    std::uint_fast8_t const qs_id)
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QF_CRIT_STAT

    // exit states from the current state to the tran. source state
    QMState const *s = cs;
    while (s != ts) {
        // exit action provided in state 's'?
        if (s->exitAction != nullptr) {
            // execute the exit action
            static_cast<void>((*s->exitAction)(this));

            QS_CRIT_ENTRY();
            QS_MEM_SYS();
            QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, qs_id)
                QS_OBJ_PRE_(this);            // this state machine object
                QS_FUN_PRE_(s->stateHandler); // the exited state handler
            QS_END_PRE_()
            QS_MEM_APP();
            QS_CRIT_EXIT();
        }

        s = s->superstate; // advance to the superstate

        if (s == nullptr) { // reached the top of a submachine?
            s = m_temp.obj; // the superstate from QM_SM_EXIT()
            QF_CRIT_ENTRY();
            Q_ASSERT_INCRIT(510, s != nullptr);
            QF_CRIT_EXIT();
        }
    }
}

//${QEP::QMsm::enterHistory_} ................................................
QState QMsm::enterHistory_(
    QMState const * const hist,
    std::uint_fast8_t const qs_id)
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QMState const *s = hist;
    QMState const *ts = m_state.obj; // tran. source
    QMState const *epath[MAX_ENTRY_DEPTH_];

    QF_CRIT_STAT

    QS_CRIT_ENTRY();
    QS_MEM_SYS();
    QS_BEGIN_PRE_(QS_QEP_TRAN_HIST, qs_id)
        QS_OBJ_PRE_(this);               // this state machine object
        QS_FUN_PRE_(ts->stateHandler);   // source state handler
        QS_FUN_PRE_(hist->stateHandler); // target state handler
    QS_END_PRE_()
    QS_MEM_APP();
    QS_CRIT_EXIT();

    std::int_fast8_t i = 0; // tran. entry path index
    while (s != ts) {
        if (s->entryAction != nullptr) {
            QF_CRIT_ENTRY();
            Q_ASSERT_INCRIT(620, i < MAX_ENTRY_DEPTH_);
            QF_CRIT_EXIT();
            epath[i] = s;
            ++i;
        }
        s = s->superstate;
        if (s == nullptr) {
            ts = s; // force exit from the for-loop
        }
    }

    // retrace the entry path in reverse (desired) order...
    while (i > 0) {
        --i;
        (*epath[i]->entryAction)(this); // run entry action in epath[i]

        QS_CRIT_ENTRY();
        QS_MEM_SYS();
        QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, qs_id)
            QS_OBJ_PRE_(this);
            QS_FUN_PRE_(epath[i]->stateHandler); // entered state handler
        QS_END_PRE_()
        QS_MEM_APP();
        QS_CRIT_EXIT();
    }

    m_state.obj = hist; // set current state to the tran. target

    // initial tran. present?
    QState r;
    if (hist->initAction != nullptr) {
        r = (*hist->initAction)(this); // execute the tran. action
    }
    else {
        r = Q_RET_NULL;
    }

    return r;
}

//${QEP::QMsm::topQMState} ...................................................
QMState const * QMsm::topQMState() const noexcept {
    return &l_msm_top_s;
}

} // namespace QP
//$enddef${QEP::QMsm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$file${src::qf::qf_act.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qf_act.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qf_act.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

// unnamed namespace for local definitions with internal linkage
namespace {
//Q_DEFINE_THIS_MODULE("qf_act")
} // unnamed namespace

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::registry_[QF_MAX_ACTIVE + 1U]} vvvvvvvvvvvvvvvvvvvvvvv
namespace QP {
QActive * QActive::registry_[QF_MAX_ACTIVE + 1U];

} // namespace QP
//$enddef${QF::QActive::registry_[QF_MAX_ACTIVE + 1U]} ^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QF-pkg} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {
namespace QF {

//${QF::QF-pkg::priv_} .......................................................
QF::Attr priv_;

//${QF::QF-pkg::bzero_} ......................................................
void bzero_(
    void * const start,
    std::uint_fast16_t const len) noexcept
{
    std::uint8_t *ptr = static_cast<std::uint8_t *>(start);
    for (std::uint_fast16_t n = len; n > 0U; --n) {
        *ptr = 0U;
        ++ptr;
    }
}

} // namespace QF
} // namespace QP
//$enddef${QF::QF-pkg} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::types::QF_LOG2} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::types::QF_LOG2} ......................................................
#ifndef QF_LOG2
std::uint_fast8_t QF_LOG2(QP::QPSetBits x) noexcept {
    static std::uint8_t const log2LUT[16] = {
        0U, 1U, 2U, 2U, 3U, 3U, 3U, 3U,
        4U, 4U, 4U, 4U, 4U, 4U, 4U, 4U
    };
    std::uint_fast8_t n = 0U;
    QP::QPSetBits t;

    #if (QF_MAX_ACTIVE > 16U)
    t = static_cast<QP::QPSetBits>(x >> 16U);
    if (t != 0U) {
        n += 16U;
        x = t;
    }
    #endif
    #if (QF_MAX_ACTIVE > 8U)
    t = (x >> 8U);
    if (t != 0U) {
        n += 8U;
        x = t;
    }
    #endif
    t = (x >> 4U);
    if (t != 0U) {
        n += 4U;
        x = t;
    }
    return n + log2LUT[x];
}
#endif // ndef QF_LOG2

} // namespace QP
//$enddef${QF::types::QF_LOG2} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$file${src::qf::qf_actq.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qf_actq.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qf_actq.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

//============================================================================
// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_MODULE("qf_actq")
} // unnamed namespace

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::post_} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::post_} ......................................................
bool QActive::post_(
    QEvt const * const e,
    std::uint_fast16_t const margin,
    void const * const sender) noexcept
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(sender);
    #endif

    #ifdef Q_UTEST // test?
    #if Q_UTEST != 0 // testing QP-stub?
    if (m_temp.fun == Q_STATE_CAST(0)) { // QActiveDummy?
        return static_cast<QActiveDummy *>(this)->fakePost(e, margin, sender);
    }
    #endif
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(102, QEvt::verify_(e));

    QEQueueCtr nFree = m_eQueue.m_nFree; // get volatile into temporary

    // test-probe#1 for faking queue overflow
    QS_TEST_PROBE_DEF(&QActive::post_)
    QS_TEST_PROBE_ID(1,
        nFree = 0U;
    )

    bool status;
    if (margin == QF::NO_MARGIN) {
        if (nFree > 0U) {
            status = true; // can post
        }
        else {
            status = false; // cannot post
            Q_ERROR_INCRIT(190); // must be able to post the event
        }
    }
    else if (nFree > static_cast<QEQueueCtr>(margin)) {
        status = true; // can post
    }
    else {
        status = false; // cannot post, but don't assert
    }

    // is it a mutable event?
    if (e->getPoolId_() != 0U) {
        QEvt_refCtr_inc_(e); // increment the reference counter
    }

    if (status) { // can post the event?

        --nFree; // one free entry just used up
        m_eQueue.m_nFree = nFree; // update the original
        if (m_eQueue.m_nMin > nFree) {
            m_eQueue.m_nMin = nFree; // update minimum so far
        }

        QS_BEGIN_PRE_(QS_QF_ACTIVE_POST, m_prio)
            QS_TIME_PRE_();       // timestamp
            QS_OBJ_PRE_(sender);  // the sender object
            QS_SIG_PRE_(e->sig);  // the signal of the event
            QS_OBJ_PRE_(this);    // this active object
            QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
            QS_EQC_PRE_(nFree);   // # free entries
            QS_EQC_PRE_(m_eQueue.m_nMin); // min # free entries
        QS_END_PRE_()

    #ifdef Q_UTEST
        // callback to examine the posted event under the same conditions
        // as producing the #QS_QF_ACTIVE_POST trace record, which are:
        // the local filter for this AO ('m_prio') is set
        if (QS_LOC_CHECK_(m_prio)) {
            QS::onTestPost(sender, this, e, status);
        }
    #endif

        if (m_eQueue.m_frontEvt == nullptr) { // empty queue?
            m_eQueue.m_frontEvt = e; // deliver event directly
    #ifdef QXK_HPP_
            if (m_state.act == Q_ACTION_CAST(0)) { // eXtended thread?
                QXTHREAD_EQUEUE_SIGNAL_(this); // signal the event queue
            }
            else {
                QACTIVE_EQUEUE_SIGNAL_(this); // signal the event queue
            }
    #else
            QACTIVE_EQUEUE_SIGNAL_(this); // signal the event queue
    #endif
        }
        // queue is not empty, insert event into the ring-buffer
        else {
            // insert event into the ring buffer (FIFO)
            m_eQueue.m_ring[m_eQueue.m_head] = e;

            if (m_eQueue.m_head == 0U) { // need to wrap head?
                m_eQueue.m_head = m_eQueue.m_end; // wrap around
            }
            // advance the head (counter clockwise)
            m_eQueue.m_head = (m_eQueue.m_head - 1U);
        }

        QF_MEM_APP();
        QF_CRIT_EXIT();
    }
    else { // cannot post the event

        QS_BEGIN_PRE_(QS_QF_ACTIVE_POST_ATTEMPT, m_prio)
            QS_TIME_PRE_();       // timestamp
            QS_OBJ_PRE_(sender);  // the sender object
            QS_SIG_PRE_(e->sig);  // the signal of the event
            QS_OBJ_PRE_(this);    // this active object
            QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
            QS_EQC_PRE_(nFree);   // # free entries
            QS_EQC_PRE_(margin);  // margin requested
        QS_END_PRE_()

    #ifdef Q_UTEST
        // callback to examine the posted event under the same conditions
        // as producing the #QS_QF_ACTIVE_POST trace record, which are:
        // the local filter for this AO ('me->prio') is set
        if (QS_LOC_CHECK_(m_prio)) {
            QS::onTestPost(sender, this, e, status);
        }
    #endif

        QF_MEM_APP();
        QF_CRIT_EXIT();

    #if (QF_MAX_EPOOL > 0U)
        QF::gc(e); // recycle the event to avoid a leak
    #endif
    }

    return status;
}

} // namespace QP
//$enddef${QF::QActive::post_} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::postLIFO} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::postLIFO} ...................................................
void QActive::postLIFO(QEvt const * const e) noexcept {
    #ifdef Q_UTEST // test?
    #if Q_UTEST != 0 // testing QP-stub?
    if (m_temp.fun == Q_STATE_CAST(0)) { // QActiveDummy?
        static_cast<QActiveDummy *>(this)->QActiveDummy::fakePostLIFO(e);
        return;
    }
    #endif
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(202, QEvt::verify_(e));

    #ifdef QXK_HPP_
    Q_REQUIRE_INCRIT(200, m_state.act != Q_ACTION_CAST(0));
    #endif

    QEQueueCtr nFree = m_eQueue.m_nFree; // get volatile into temporary

    // test-probe#1 for faking queue overflow
    QS_TEST_PROBE_DEF(&QActive::postLIFO)
    QS_TEST_PROBE_ID(1,
        nFree = 0U;
    )

    Q_REQUIRE_INCRIT(201, nFree != 0U);

    if (e->getPoolId_() != 0U) { // is it a mutable event?
        QEvt_refCtr_inc_(e); // increment the reference counter
    }

    --nFree; // one free entry just used up
    m_eQueue.m_nFree = nFree; // update the original
    if (m_eQueue.m_nMin > nFree) {
        m_eQueue.m_nMin = nFree; // update minimum so far
    }

    QS_BEGIN_PRE_(QS_QF_ACTIVE_POST_LIFO, m_prio)
        QS_TIME_PRE_();       // timestamp
        QS_SIG_PRE_(e->sig);  // the signal of this event
        QS_OBJ_PRE_(this);    // this active object
        QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
        QS_EQC_PRE_(nFree);   // # free entries
        QS_EQC_PRE_(m_eQueue.m_nMin); // min # free entries
    QS_END_PRE_()

    #ifdef Q_UTEST
    // callback to examine the posted event under the same conditions
    // as producing the #QS_QF_ACTIVE_POST trace record, which are:
    // the local filter for this AO ('m_prio') is set
    if (QS_LOC_CHECK_(m_prio)) {
        QS::onTestPost(nullptr, this, e, true);
    }
    #endif

    QEvt const * const frontEvt = m_eQueue.m_frontEvt;
    m_eQueue.m_frontEvt = e; // deliver the event directly to the front

    if (frontEvt == nullptr) { // was the queue empty?
        QACTIVE_EQUEUE_SIGNAL_(this); // signal the event queue
    }
    else { // queue was not empty, leave the event in the ring-buffer
        m_eQueue.m_tail = (m_eQueue.m_tail + 1U);
        if (m_eQueue.m_tail == m_eQueue.m_end) { // need to wrap the tail?
            m_eQueue.m_tail = 0U; // wrap around
        }

        m_eQueue.m_ring[m_eQueue.m_tail] = frontEvt;
    }

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

} // namespace QP
//$enddef${QF::QActive::postLIFO} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::get_} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::get_} .......................................................
QEvt const * QActive::get_() noexcept {
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    QACTIVE_EQUEUE_WAIT_(this); // wait for event to arrive directly

    // always remove evt from the front
    QEvt const * const e = m_eQueue.m_frontEvt;
    QEQueueCtr const nFree = m_eQueue.m_nFree + 1U; // get volatile into tmp
    m_eQueue.m_nFree = nFree; // update the # free

    if (nFree <= m_eQueue.m_end) { // any events in the ring buffer?
        // remove event from the tail
        m_eQueue.m_frontEvt = m_eQueue.m_ring[m_eQueue.m_tail];
        if (m_eQueue.m_tail == 0U) { // need to wrap the tail?
            m_eQueue.m_tail = m_eQueue.m_end; // wrap around
        }
        m_eQueue.m_tail = (m_eQueue.m_tail - 1U);

        QS_BEGIN_PRE_(QS_QF_ACTIVE_GET, m_prio)
            QS_TIME_PRE_();       // timestamp
            QS_SIG_PRE_(e->sig);  // the signal of this event
            QS_OBJ_PRE_(this);    // this active object
            QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
            QS_EQC_PRE_(nFree);   // # free entries
        QS_END_PRE_()
    }
    else {
        m_eQueue.m_frontEvt = nullptr; // the queue becomes empty

        // all entries in the queue must be free (+1 for fronEvt)
        Q_ASSERT_INCRIT(310, nFree == (m_eQueue.m_end + 1U));

        QS_BEGIN_PRE_(QS_QF_ACTIVE_GET_LAST, m_prio)
            QS_TIME_PRE_();       // timestamp
            QS_SIG_PRE_(e->sig);  // the signal of this event
            QS_OBJ_PRE_(this);    // this active object
            QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
        QS_END_PRE_()
    }

    QF_MEM_APP();
    QF_CRIT_EXIT();

    return e;
}

} // namespace QP
//$enddef${QF::QActive::get_} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QTicker} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QTicker} .............................................................

//${QF::QTicker::QTicker} ....................................................
QTicker::QTicker(std::uint_fast8_t const tickRate) noexcept
: QActive(nullptr)
{
    // reuse m_head for tick-rate
    m_eQueue.m_head = static_cast<QEQueueCtr>(tickRate);
}

//${QF::QTicker::init} .......................................................
void QTicker::init(
    void const * const e,
    std::uint_fast8_t const qs_id)
{
    Q_UNUSED_PAR(e);
    Q_UNUSED_PAR(qs_id);

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    m_eQueue.m_tail = 0U;

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

//${QF::QTicker::dispatch} ...................................................
void QTicker::dispatch(
    QEvt const * const e,
    std::uint_fast8_t const qs_id)
{
    Q_UNUSED_PAR(e);
    Q_UNUSED_PAR(qs_id);

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    QEQueueCtr nTicks = m_eQueue.m_tail; // save # of ticks
    m_eQueue.m_tail = 0U; // clear the # ticks

    QF_MEM_APP();
    QF_CRIT_EXIT();

    for (; nTicks > 0U; --nTicks) {
        QTimeEvt::tick(static_cast<std::uint_fast8_t>(m_eQueue.m_head),
                       this);
    }
}

//${QF::QTicker::trig_} ......................................................
void QTicker::trig_(void const * const sender) noexcept {
    #ifndef Q_SPY
    Q_UNUSED_PAR(sender);
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    if (m_eQueue.m_frontEvt == nullptr) {

        static QEvt const tickEvt(0U); // immutable event

        m_eQueue.m_frontEvt = &tickEvt; // deliver event directly
        m_eQueue.m_nFree = (m_eQueue.m_nFree - 1U); // one less free event

        QACTIVE_EQUEUE_SIGNAL_(this); // signal the event queue
    }

    // account for one more tick event
    m_eQueue.m_tail = (m_eQueue.m_tail + 1U);

    QS_BEGIN_PRE_(QS_QF_ACTIVE_POST, m_prio)
        QS_TIME_PRE_();      // timestamp
        QS_OBJ_PRE_(sender); // the sender object
        QS_SIG_PRE_(0U);     // the signal of the event
        QS_OBJ_PRE_(this);   // this active object
        QS_2U8_PRE_(0U, 0U); // poolId & refCtr
        QS_EQC_PRE_(0U);     // # free entries
        QS_EQC_PRE_(0U);     // min # free entries
    QS_END_PRE_()

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

} // namespace QP
//$enddef${QF::QTicker} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$file${src::qf::qf_defer.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qf_defer.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qf_defer.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_MODULE("qf_defer")
} // unnamed namespace

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::defer} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::defer} ......................................................
bool QActive::defer(
    QEQueue * const eq,
    QEvt const * const e) const noexcept
{
    bool const status = eq->post(e, 0U, m_prio);

    QS_CRIT_STAT
    QS_CRIT_ENTRY();
    QS_MEM_SYS();
    QS_BEGIN_PRE_(QS_QF_ACTIVE_DEFER, m_prio)
        QS_TIME_PRE_();      // time stamp
        QS_OBJ_PRE_(this);   // this active object
        QS_OBJ_PRE_(eq);     // the deferred queue
        QS_SIG_PRE_(e->sig); // the signal of the event
        QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
    QS_END_PRE_()
    QS_MEM_APP();
    QS_CRIT_EXIT();

    return status;
}

} // namespace QP
//$enddef${QF::QActive::defer} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::recall} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::recall} .....................................................
bool QActive::recall(QEQueue * const eq) noexcept {
    QEvt const * const e = eq->get(m_prio); // get evt from deferred queue
    QF_CRIT_STAT

    bool recalled;
    if (e != nullptr) { // event available?
        postLIFO(e); // post it to the _front_ of the AO's queue

        QF_CRIT_ENTRY();
        QF_MEM_SYS();

        if (e->getPoolId_() != 0U) { // is it a mutable event?

            // after posting to the AO's queue the event must be referenced
            // at least twice: once in the deferred event queue (eq->get()
            // did NOT decrement the reference counter) and once in the
            // AO's event queue.
            Q_ASSERT_INCRIT(210, e->refCtr_ >= 2U);

            // we need to decrement the reference counter once, to account
            // for removing the event from the deferred event queue.
            QEvt_refCtr_dec_(e); // decrement the reference counter
        }

        QS_BEGIN_PRE_(QS_QF_ACTIVE_RECALL, m_prio)
            QS_TIME_PRE_();      // time stamp
            QS_OBJ_PRE_(this);   // this active object
            QS_OBJ_PRE_(eq);     // the deferred queue
            QS_SIG_PRE_(e->sig); // the signal of the event
            QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
        QS_END_PRE_()

        QF_MEM_APP();
        QF_CRIT_EXIT();

        recalled = true;
    }
    else {
        QS_CRIT_ENTRY();
        QS_MEM_SYS();

        QS_BEGIN_PRE_(QS_QF_ACTIVE_RECALL_ATTEMPT, m_prio)
            QS_TIME_PRE_();      // time stamp
            QS_OBJ_PRE_(this);   // this active object
            QS_OBJ_PRE_(eq);     // the deferred queue
        QS_END_PRE_()

        QS_MEM_APP();
        QS_CRIT_EXIT();

        recalled = false;
    }
    return recalled;
}

} // namespace QP
//$enddef${QF::QActive::recall} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::flushDeferred} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::flushDeferred} ..............................................
std::uint_fast16_t QActive::flushDeferred(QEQueue * const eq) const noexcept {
    std::uint_fast16_t n = 0U;
    for (QEvt const *e = eq->get(m_prio);
         e != nullptr;
         e = eq->get(m_prio))
    {
        ++n; // count the flushed event
    #if (QF_MAX_EPOOL > 0U)
        QF::gc(e); // garbage collect
    #endif
    }
    return n;
}

} // namespace QP
//$enddef${QF::QActive::flushDeferred} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$file${src::qf::qf_dyn.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qf_dyn.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qf_dyn.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

#if (QF_MAX_EPOOL > 0U)     // mutable events configured?

// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_MODULE("qf_dyn")
} // unnamed namespace

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QF-dyn} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {
namespace QF {

//${QF::QF-dyn::poolInit} ....................................................
void poolInit(
    void * const poolSto,
    std::uint_fast32_t const poolSize,
    std::uint_fast16_t const evtSize) noexcept
{
    std::uint_fast8_t const poolId = priv_.maxPool_;

    // see precondition{qf_dyn,200} and precondition{qf_dyn,201}
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(200, poolId < QF_MAX_EPOOL);
    if (poolId > 0U) {
        Q_REQUIRE_INCRIT(201,
            QF_EPOOL_EVENT_SIZE_(priv_.ePool_[poolId - 1U]) < evtSize);
    }
    priv_.maxPool_ = poolId + 1U; // one more pool

    QF_MEM_APP();
    QF_CRIT_EXIT();

    // perform the port-dependent initialization of the event-pool
    QF_EPOOL_INIT_(priv_.ePool_[poolId], poolSto, poolSize, evtSize);

    #ifdef Q_SPY
    // generate the object-dictionary entry for the initialized pool
    {
        std::uint8_t obj_name[9] = "EvtPool?";
        obj_name[7] = static_cast<std::uint8_t>(
            static_cast<std::uint8_t>('0')
            + static_cast<std::uint8_t>(poolId + 1U));
        QS_CRIT_ENTRY();
        QS_MEM_SYS();
        QS::obj_dict_pre_(&priv_.ePool_[poolId],
                          reinterpret_cast<char *>(&obj_name[0]));
        QS_MEM_APP();
        QS_CRIT_EXIT();
    }
    #endif // Q_SPY
}

//${QF::QF-dyn::poolGetMaxBlockSize} .........................................
std::uint_fast16_t poolGetMaxBlockSize() noexcept {
    return QF_EPOOL_EVENT_SIZE_(priv_.ePool_[priv_.maxPool_ - 1U]);
}

//${QF::QF-dyn::getPoolMin} ..................................................
std::uint_fast16_t getPoolMin(std::uint_fast8_t const poolId) noexcept {
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(400, (poolId <= QF_MAX_EPOOL)
                      && (0U < poolId) && (poolId <= priv_.maxPool_));

    std::uint_fast16_t const min = static_cast<std::uint_fast16_t>(
        priv_.ePool_[poolId - 1U].getNMin());

    QF_MEM_APP();
    QF_CRIT_EXIT();

    return min;
}

//${QF::QF-dyn::newX_} .......................................................
QEvt * newX_(
    std::uint_fast16_t const evtSize,
    std::uint_fast16_t const margin,
    enum_t const sig) noexcept
{
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    // find the pool id that fits the requested event size...
    std::uint_fast8_t poolId = 0U; // zero-based poolId initially
    for (; poolId < priv_.maxPool_; ++poolId) {
        if (evtSize <= QF_EPOOL_EVENT_SIZE_(priv_.ePool_[poolId])) {
            break;
        }
    }

    // precondition:
    // - cannot run out of registered pools
    Q_REQUIRE_INCRIT(300, poolId < priv_.maxPool_);

    ++poolId; // convert to 1-based poolId

    QF_MEM_APP();
    QF_CRIT_EXIT();

    // get event e (port-dependent)...
    QEvt *e;
    #ifdef Q_SPY
    QF_EPOOL_GET_(priv_.ePool_[poolId - 1U], e,
                  ((margin != NO_MARGIN) ? margin : 0U),
                  static_cast<std::uint_fast8_t>(QS_EP_ID) + poolId);
    #else
    QF_EPOOL_GET_(priv_.ePool_[poolId - 1U], e,
                  ((margin != NO_MARGIN) ? margin : 0U), 0U);
    #endif

    if (e != nullptr) { // was e allocated correctly?
        e->sig     = static_cast<QSignal>(sig); // set the signal
        e->refCtr_ = 0U; // initialize the reference counter to 0
        e->evtTag_ = static_cast<std::uint8_t>(QEvt::MARKER | poolId);

        QS_CRIT_ENTRY();
        QS_MEM_SYS();
        QS_BEGIN_PRE_(QS_QF_NEW,
                static_cast<std::uint_fast8_t>(QS_EP_ID) + poolId)
            QS_TIME_PRE_();        // timestamp
            QS_EVS_PRE_(evtSize);  // the size of the event
            QS_SIG_PRE_(sig);      // the signal of the event
        QS_END_PRE_()
        QS_MEM_APP();
        QS_CRIT_EXIT();
    }
    else { // event was not allocated

        QF_CRIT_ENTRY();
        // This assertion means that the event allocation failed,
        // and this failure cannot be tolerated. The most frequent
        // reason is an event leak in the application.
        Q_ASSERT_INCRIT(320, margin != NO_MARGIN);

        QS_MEM_SYS();
        QS_BEGIN_PRE_(QS_QF_NEW_ATTEMPT,
                static_cast<std::uint_fast8_t>(QS_EP_ID) + poolId)
            QS_TIME_PRE_();        // timestamp
            QS_EVS_PRE_(evtSize);  // the size of the event
            QS_SIG_PRE_(sig);      // the signal of the event
        QS_END_PRE_()
        QS_MEM_APP();

        QF_CRIT_EXIT();
    }

    // the returned event e is guaranteed to be valid (not NULL)
    // if we can't tolerate failed allocation
    return e;
}

//${QF::QF-dyn::gc} ..........................................................
void gc(QEvt const * const e) noexcept {
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    Q_REQUIRE_INCRIT(402, QEvt::verify_(e));

    std::uint_fast8_t const poolId = e->getPoolId_();

    if (poolId != 0U) { // is it a pool event (mutable)?
        QF_MEM_SYS();

        if (e->refCtr_ > 1U) { // isn't this the last reference?

            QS_BEGIN_PRE_(QS_QF_GC_ATTEMPT,
                    static_cast<std::uint_fast8_t>(QS_EP_ID) + poolId)
                QS_TIME_PRE_();       // timestamp
                QS_SIG_PRE_(e->sig);  // the signal of the event
                QS_2U8_PRE_(poolId, e->refCtr_); // poolId & refCtr
            QS_END_PRE_()

            QEvt_refCtr_dec_(e); // decrement the ref counter

            QF_MEM_APP();
            QF_CRIT_EXIT();
        }
        else { // this is the last reference to this event, recycle it

            QS_BEGIN_PRE_(QS_QF_GC,
                    static_cast<std::uint_fast8_t>(QS_EP_ID) + poolId)
                QS_TIME_PRE_();       // timestamp
                QS_SIG_PRE_(e->sig);  // the signal of the event
                QS_2U8_PRE_(poolId, e->refCtr_); // poolId & refCtr
            QS_END_PRE_()

            // pool number must be in range
            Q_ASSERT_INCRIT(410, (poolId <= priv_.maxPool_)
                                  && (poolId <= QF_MAX_EPOOL));
            QF_MEM_APP();
            QF_CRIT_EXIT();

            // NOTE: casting 'const' away is legit because it's a pool event
    #ifdef Q_SPY
            QF_EPOOL_PUT_(priv_.ePool_[poolId - 1U],
                QF_CONST_CAST_(QEvt*, e),
                static_cast<std::uint_fast8_t>(QS_EP_ID) + poolId);
    #else
            QF_EPOOL_PUT_(priv_.ePool_[poolId - 1U],
                QF_CONST_CAST_(QEvt*, e), 0U);
    #endif
        }
    }
    else {
        QF_CRIT_EXIT();
    }
}

//${QF::QF-dyn::newRef_} .....................................................
QEvt const * newRef_(
    QEvt const * const e,
    QEvt const * const evtRef) noexcept
{
    #ifdef Q_UNSAFE
    Q_UNUSED_PAR(evtRef);
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();

    Q_REQUIRE_INCRIT(502, QEvt::verify_(e));

    std::uint_fast8_t const poolId = e->getPoolId_();

    Q_REQUIRE_INCRIT(500, (poolId != 0U)
        && (evtRef == nullptr));

    QEvt_refCtr_inc_(e); // increments the ref counter

    QS_MEM_SYS();
    QS_BEGIN_PRE_(QS_QF_NEW_REF,
            static_cast<std::uint_fast8_t>(QS_EP_ID) + poolId)
        QS_TIME_PRE_();       // timestamp
        QS_SIG_PRE_(e->sig);  // the signal of the event
        QS_2U8_PRE_(poolId, e->refCtr_); // poolId & refCtr
    QS_END_PRE_()
    QS_MEM_APP();

    QF_CRIT_EXIT();

    return e;
}

//${QF::QF-dyn::deleteRef_} ..................................................
void deleteRef_(QEvt const * const evtRef) noexcept {
    QEvt const * const e = evtRef;

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    Q_REQUIRE_INCRIT(602, QEvt::verify_(e));

    #ifdef Q_SPY
    std::uint_fast8_t const poolId = e->getPoolId_();
    #endif

    QS_MEM_SYS();
    QS_BEGIN_PRE_(QS_QF_DELETE_REF,
            static_cast<std::uint_fast8_t>(QS_EP_ID) + poolId)
        QS_TIME_PRE_();       // timestamp
        QS_SIG_PRE_(e->sig);  // the signal of the event
        QS_2U8_PRE_(poolId, e->refCtr_); // poolId & refCtr
    QS_END_PRE_()
    QS_MEM_APP();

    QF_CRIT_EXIT();

    #if (QF_MAX_EPOOL > 0U)
    gc(evtRef); // recycle the referenced event
    #endif
}

} // namespace QF
} // namespace QP
//$enddef${QF::QF-dyn} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

#endif // (QF_MAX_EPOOL > 0U) mutable events configured
//$file${src::qf::qf_mem.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qf_mem.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qf_mem.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_MODULE("qf_mem")
} // unnamed namespace

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QMPool} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QMPool} ..............................................................

//${QF::QMPool::init} ........................................................
void QMPool::init(
    void * const poolSto,
    std::uint_fast32_t const poolSize,
    std::uint_fast16_t const blockSize) noexcept
{
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(100, (poolSto != nullptr)
        && (poolSize >= static_cast<std::uint_fast32_t>(sizeof(QFreeBlock)))
        && (static_cast<std::uint_fast16_t>(blockSize + sizeof(QFreeBlock))
            > blockSize));

    m_free_head = static_cast<QFreeBlock *>(poolSto);

    // find # free blocks in a memory block, NO DIVISION
    m_blockSize = static_cast<QMPoolSize>(sizeof(QFreeBlock));
    std::uint_fast16_t nblocks = 1U;
    while (m_blockSize < static_cast<QMPoolSize>(blockSize)) {
        m_blockSize += static_cast<QMPoolSize>(sizeof(QFreeBlock));
        ++nblocks;
    }

    // the pool buffer must fit at least one rounded-up block
    Q_ASSERT_INCRIT(110, poolSize >= m_blockSize);

    // start at the head of the free list
    QFreeBlock *fb = m_free_head;
    m_nTot = 1U; // the last block already in the list

    // chain all blocks together in a free-list...
    for (std::uint_fast32_t size = poolSize - m_blockSize;
         size >= static_cast<std::uint_fast32_t>(m_blockSize);
         size -= static_cast<std::uint_fast32_t>(m_blockSize))
    {
        fb->m_next = &fb[nblocks]; // point next link to next block
    #ifndef Q_UNSAFE
        fb->m_next_dis = ~Q_UINTPTR_CAST_(fb->m_next);
    #endif
        fb = fb->m_next; // advance to the next block
        ++m_nTot;        // one more free block in the pool
    }

    fb->m_next  = nullptr; // the last link points to NULL
    #ifndef Q_UNSAFE
    fb->m_next_dis = ~Q_UINTPTR_CAST_(fb->m_next);
    #endif

    fb->m_next = nullptr; // the last link points to NULL
    m_nFree = m_nTot;  // all blocks are free
    m_nMin  = m_nTot;  // the minimum # free blocks
    m_start = static_cast<QFreeBlock *>(poolSto); // original start
    m_end   = fb;      // the last block in this pool

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

//${QF::QMPool::get} .........................................................
void * QMPool::get(
    std::uint_fast16_t const margin,
    std::uint_fast8_t const qs_id) noexcept
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    // have more free blocks than the requested margin?
    QFreeBlock *fb;
    if (m_nFree > static_cast<QMPoolCtr>(margin)) {
        fb = m_free_head;  // get a free block

        //  a free block must be valid
        Q_ASSERT_INCRIT(300, fb != nullptr);

        QFreeBlock * const fb_next = fb->m_next;

        // the free block must have integrity (duplicate inverse storage)
        Q_ASSERT_INCRIT(302, Q_UINTPTR_CAST_(fb_next)
                              == static_cast<std::uintptr_t>(~fb->m_next_dis));

        m_nFree = (m_nFree - 1U); // one free block less
        if (m_nFree == 0U) { // is the pool becoming empty?
            // pool is becoming empty, so the next free block must be NULL
            Q_ASSERT_INCRIT(320, fb_next == nullptr);

            m_nMin = 0U; // remember that the pool got empty
        }
        else {
            // invariant:
            // The pool is not empty, so the next free-block pointer,
            // so the next free block must be in range.

            // NOTE: The next free block pointer can fall out of range
            // when the client code writes past the memory block, thus
            // corrupting the next block.
            Q_ASSERT_INCRIT(330,
                QF_PTR_RANGE_(fb_next, m_start, m_end));

            // is the # free blocks the new minimum so far?
            if (m_nMin > m_nFree) {
                m_nMin = m_nFree; // remember the minimum so far
            }
        }

        m_free_head = fb_next; // set the head to the next free block

        QS_BEGIN_PRE_(QS_QF_MPOOL_GET, qs_id)
            QS_TIME_PRE_();         // timestamp
            QS_OBJ_PRE_(this);      // this memory pool
            QS_MPC_PRE_(m_nFree);   // # of free blocks in the pool
            QS_MPC_PRE_(m_nMin);    // min # free blocks ever in the pool
        QS_END_PRE_()
    }
    else { // don't have enough free blocks at this point
        fb = nullptr;

        QS_BEGIN_PRE_(QS_QF_MPOOL_GET_ATTEMPT, qs_id)
            QS_TIME_PRE_();         // timestamp
            QS_OBJ_PRE_(this);      // this memory pool
            QS_MPC_PRE_(m_nFree);   // # of free blocks in the pool
            QS_MPC_PRE_(margin);    // the requested margin
        QS_END_PRE_()
    }

    QF_MEM_APP();
    QF_CRIT_EXIT();

    return fb; // return the block or nullptr to the caller
}

//${QF::QMPool::put} .........................................................
void QMPool::put(
    void * const block,
    std::uint_fast8_t const qs_id) noexcept
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QFreeBlock * const fb = static_cast<QFreeBlock *>(block);

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(200, (m_nFree < m_nTot)
                           && QF_PTR_RANGE_(fb, m_start, m_end));

    fb->m_next = m_free_head; // link into list
    #ifndef Q_UNSAFE
    fb->m_next_dis = static_cast<std::uintptr_t>(
                         ~Q_UINTPTR_CAST_(fb->m_next));
    #endif

    // set as new head of the free list
    m_free_head = static_cast<QFreeBlock *>(block);

    m_nFree = m_nFree + 1U; // one more free block in this pool

    QS_BEGIN_PRE_(QS_QF_MPOOL_PUT, qs_id)
        QS_TIME_PRE_();         // timestamp
        QS_OBJ_PRE_(this);      // this memory pool
        QS_MPC_PRE_(m_nFree);   // the # free blocks in the pool
    QS_END_PRE_()

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

//${QF::QMPool::getBlockSize} ................................................
QMPoolSize QMPool::getBlockSize() const noexcept {
    return m_blockSize;
}

} // namespace QP
//$enddef${QF::QMPool} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$file${src::qf::qf_ps.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qf_ps.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qf_ps.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_MODULE("qf_ps")
} // unnamed namespace

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::subscrList_} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {
QSubscrList * QActive::subscrList_;

} // namespace QP
//$enddef${QF::QActive::subscrList_} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::maxPubSignal_} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {
enum_t QActive::maxPubSignal_;

} // namespace QP
//$enddef${QF::QActive::maxPubSignal_} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::psInit} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::psInit} .....................................................
void QActive::psInit(
    QSubscrList * const subscrSto,
    enum_t const maxSignal) noexcept
{
    subscrList_   = subscrSto;
    maxPubSignal_ = maxSignal;

    // initialize the subscriber list
    for (enum_t sig = 0; sig < maxSignal; ++sig) {
        subscrSto[sig].m_set.setEmpty();
    #ifndef Q_UNSAFE
        subscrSto[sig].m_set.update_(&subscrSto[sig].m_set_dis);
    #endif
    }
}

} // namespace QP
//$enddef${QF::QActive::psInit} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::publish_} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::publish_} ...................................................
void QActive::publish_(
    QEvt const * const e,
    void const * const sender,
    std::uint_fast8_t const qs_id) noexcept
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(sender);
    Q_UNUSED_PAR(qs_id);
    #endif

    QSignal const sig = e->sig;

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(200, sig < static_cast<QSignal>(maxPubSignal_));
    Q_REQUIRE_INCRIT(202,
        subscrList_[sig].m_set.verify_(&subscrList_[sig].m_set_dis));

    QS_BEGIN_PRE_(QS_QF_PUBLISH, qs_id)
        QS_TIME_PRE_();          // the timestamp
        QS_OBJ_PRE_(sender);     // the sender object
        QS_SIG_PRE_(e->sig);     // the signal of the event
        QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
    QS_END_PRE_()

    // is it a mutable event?
    if (e->getPoolId_() != 0U) {
        // NOTE: The reference counter of a mutable event is incremented to
        // prevent premature recycling of the event while the multicasting
        // is still in progress. At the end of the function, the garbage
        // collector step (QF::gc()) decrements the reference counter and
        // recycles the event if the counter drops to zero. This covers the
        // case when the event was published without any subscribers.
        QEvt_refCtr_inc_(e);
    }

    // make a local, modifiable copy of the subscriber set
    QPSet subscrSet = subscrList_[sig].m_set;

    QF_MEM_APP();
    QF_CRIT_EXIT();

    if (subscrSet.notEmpty()) { // any subscribers?
        // highest-prio subscriber
        std::uint_fast8_t p = subscrSet.findMax();

        QF_CRIT_ENTRY();
        QF_MEM_SYS();

        QActive *a = registry_[p];
        // the AO must be registered with the framework
        Q_ASSERT_INCRIT(210, a != nullptr);

        QF_MEM_APP();
        QF_CRIT_EXIT();

        QF_SCHED_STAT_
        QF_SCHED_LOCK_(p); // lock the scheduler up to AO's prio
        std::uint_fast8_t limit = QF_MAX_ACTIVE + 1U;
        do { // loop over all subscribers
            --limit;

            // POST() asserts internally if the queue overflows
            a->POST(e, sender);

            subscrSet.remove(p); // remove the handled subscriber
            if (subscrSet.notEmpty()) {  // still more subscribers?
                p = subscrSet.findMax(); // highest-prio subscriber

                QF_CRIT_ENTRY();
                QF_MEM_SYS();

                a = registry_[p];
                // the AO must be registered with the framework
                Q_ASSERT_INCRIT(220, a != nullptr);

                QF_MEM_APP();
                QF_CRIT_EXIT();
            }
            else {
                p = 0U; // no more subscribers
            }
        } while ((p != 0U) && (limit > 0U));

        QF_CRIT_ENTRY();
        Q_ENSURE_INCRIT(290, p == 0U);
        QF_CRIT_EXIT();

        QF_SCHED_UNLOCK_(); // unlock the scheduler
    }

    // The following garbage collection step decrements the reference counter
    // and recycles the event if the counter drops to zero. This covers both
    // cases when the event was published with or without any subscribers.
    #if (QF_MAX_EPOOL > 0U)
    QF::gc(e);
    #endif
}

} // namespace QP
//$enddef${QF::QActive::publish_} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::subscribe} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::subscribe} ..................................................
void QActive::subscribe(enum_t const sig) const noexcept {
    std::uint_fast8_t const p = static_cast<std::uint_fast8_t>(m_prio);

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(300, (Q_USER_SIG <= sig)
        && (sig < maxPubSignal_)
        && (0U < p) && (p <= QF_MAX_ACTIVE)
        && (registry_[p] == this));
    Q_REQUIRE_INCRIT(302,
        subscrList_[sig].m_set.verify_(&subscrList_[sig].m_set_dis));

    QS_BEGIN_PRE_(QS_QF_ACTIVE_SUBSCRIBE, m_prio)
        QS_TIME_PRE_();    // timestamp
        QS_SIG_PRE_(sig);  // the signal of this event
        QS_OBJ_PRE_(this); // this active object
    QS_END_PRE_()

    // insert the prio. into the subscriber set
    subscrList_[sig].m_set.insert(p);
    #ifndef Q_UNSAFE
    subscrList_[sig].m_set.update_(&subscrList_[sig].m_set_dis);
    #endif

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

} // namespace QP
//$enddef${QF::QActive::subscribe} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::unsubscribe} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::unsubscribe} ................................................
void QActive::unsubscribe(enum_t const sig) const noexcept {
    std::uint_fast8_t const p = static_cast<std::uint_fast8_t>(m_prio);

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(400, (Q_USER_SIG <= sig)
        && (sig < maxPubSignal_)
        && (0U < p) && (p <= QF_MAX_ACTIVE)
        && (registry_[p] == this));
    Q_REQUIRE_INCRIT(402,
        subscrList_[sig].m_set.verify_(&subscrList_[sig].m_set_dis));

    QS_BEGIN_PRE_(QS_QF_ACTIVE_UNSUBSCRIBE, m_prio)
        QS_TIME_PRE_();    // timestamp
        QS_SIG_PRE_(sig);  // the signal of this event
        QS_OBJ_PRE_(this); // this active object
    QS_END_PRE_()

    // remove the prio. from the subscriber set
    subscrList_[sig].m_set.remove(p);
    #ifndef Q_UNSAFE
    subscrList_[sig].m_set.update_(&subscrList_[sig].m_set_dis);
    #endif

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

} // namespace QP
//$enddef${QF::QActive::unsubscribe} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::unsubscribeAll} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::unsubscribeAll} .............................................
void QActive::unsubscribeAll() const noexcept {
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    std::uint_fast8_t const p = static_cast<std::uint_fast8_t>(m_prio);

    Q_REQUIRE_INCRIT(500, (0U < p) && (p <= QF_MAX_ACTIVE)
                           && (registry_[p] == this));
    enum_t const maxPubSig = maxPubSignal_;

    QF_MEM_APP();
    QF_CRIT_EXIT();

    for (enum_t sig = Q_USER_SIG; sig < maxPubSig; ++sig) {
        QF_CRIT_ENTRY();
        QF_MEM_SYS();

        if (subscrList_[sig].m_set.hasElement(p)) {
            subscrList_[sig].m_set.remove(p);
    #ifndef Q_UNSAFE
            subscrList_[sig].m_set.update_(&subscrList_[sig].m_set_dis);
    #endif
            QS_BEGIN_PRE_(QS_QF_ACTIVE_UNSUBSCRIBE, m_prio)
                QS_TIME_PRE_();    // timestamp
                QS_SIG_PRE_(sig);  // the signal of this event
                QS_OBJ_PRE_(this); // this active object
            QS_END_PRE_()
        }
        QF_MEM_APP();
        QF_CRIT_EXIT();

        QF_CRIT_EXIT_NOP(); // prevent merging critical sections
    }
}

} // namespace QP
//$enddef${QF::QActive::unsubscribeAll} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$file${src::qf::qf_qact.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qf_qact.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qf_qact.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_MODULE("qf_qact")
} // unnamed namespace

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::QActive} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::QActive} ....................................................
QActive::QActive(QStateHandler const initial) noexcept
  : QAsm(),
    m_prio(0U),
    m_pthre(0U)
{
    m_state.fun = Q_STATE_CAST(&top);
    m_temp.fun  = initial;
}

} // namespace QP
//$enddef${QF::QActive::QActive} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::register_} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::register_} ..................................................
void QActive::register_() noexcept {
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    if (m_pthre == 0U) { // preemption-threshold not defined?
        m_pthre = m_prio; // apply the default
    }

    #ifndef Q_UNSAFE

    Q_REQUIRE_INCRIT(100, (0U < m_prio) && (m_prio <= QF_MAX_ACTIVE)
                      && (registry_[m_prio] == nullptr)
                      && (m_prio <= m_pthre));

    std::uint8_t prev_thre = m_pthre;
    std::uint8_t next_thre = m_pthre;

    std::uint_fast8_t p;
    for (p = static_cast<std::uint_fast8_t>(m_prio) - 1U; p > 0U; --p) {
        if (registry_[p] != nullptr) {
            prev_thre = registry_[p]->m_pthre;
            break;
        }
    }
    for (p = static_cast<std::uint_fast8_t>(m_prio) + 1U;
         p <= QF_MAX_ACTIVE; ++p)
    {
        if (registry_[p] != nullptr) {
            next_thre = registry_[p]->m_pthre;
            break;
        }
    }

    Q_ASSERT_INCRIT(190, (prev_thre <= m_pthre)
                          && (m_pthre <= next_thre));
    #endif // Q_UNSAFE

    // register the AO at the QF-prio.
    registry_[m_prio] = this;

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

} // namespace QP
//$enddef${QF::QActive::register_} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QActive::unregister_} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QActive::unregister_} ................................................
void QActive::unregister_() noexcept {
    std::uint_fast8_t const p = static_cast<std::uint_fast8_t>(m_prio);

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(200, (0U < p) && (p <= QF_MAX_ACTIVE)
                      && (registry_[p] == this));
    registry_[p] = nullptr; // free-up the priority level
    m_state.fun = nullptr; // invalidate the state

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

} // namespace QP
//$enddef${QF::QActive::unregister_} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$file${src::qf::qf_qeq.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qf_qeq.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qf_qeq.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_MODULE("qf_qeq")
} // unnamed namespace

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QEQueue} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QEQueue} .............................................................

//${QF::QEQueue::init} .......................................................
void QEQueue::init(
    QEvt const * qSto[],
    std::uint_fast16_t const qLen) noexcept
{
    m_frontEvt = nullptr; // no events in the queue
    m_ring     = &qSto[0];
    m_end      = static_cast<QEQueueCtr>(qLen);
    if (qLen > 0U) {
        m_head = 0U;
        m_tail = 0U;
    }
    m_nFree    = static_cast<QEQueueCtr>(qLen + 1U); //+1 for frontEvt
    m_nMin     = m_nFree;
}

//${QF::QEQueue::post} .......................................................
bool QEQueue::post(
    QEvt const * const e,
    std::uint_fast16_t const margin,
    std::uint_fast8_t const qs_id) noexcept
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(200, e != nullptr);

    QEQueueCtr nFree = m_nFree; // get volatile into temporary

    // required margin available?
    bool status;
    if (((margin == QF::NO_MARGIN) && (nFree > 0U))
        || (nFree > static_cast<QEQueueCtr>(margin)))
    {
        // is it a mutable event?
        if (e->getPoolId_() != 0U) {
            QEvt_refCtr_inc_(e); // increment the reference counter
        }

        --nFree; // one free entry just used up
        m_nFree = nFree; // update the original
        if (m_nMin > nFree) {
            m_nMin = nFree; // update minimum so far
        }

        QS_BEGIN_PRE_(QS_QF_EQUEUE_POST, qs_id)
            QS_TIME_PRE_();        // timestamp
            QS_SIG_PRE_(e->sig);   // the signal of this event
            QS_OBJ_PRE_(this);     // this queue object
            QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
            QS_EQC_PRE_(nFree);    // # free entries
            QS_EQC_PRE_(m_nMin);   // min # free entries
        QS_END_PRE_()

        if (m_frontEvt == nullptr) { // was the queue empty?
            m_frontEvt = e; // deliver event directly
        }
        else { // queue was not empty, insert event into the ring-buffer
            // insert event into the ring buffer (FIFO)
            m_ring[m_head] = e; // insert e into buffer

            // need to wrap?
            if (m_head == 0U) {
                m_head = m_end; // wrap around
            }
            m_head = (m_head - 1U);
        }
        status = true; // event posted successfully
    }
    else { // event cannot be posted
        // dropping events must be acceptable
        Q_ASSERT_INCRIT(210, margin != QF::NO_MARGIN);

        QS_BEGIN_PRE_(QS_QF_EQUEUE_POST_ATTEMPT, qs_id)
            QS_TIME_PRE_();        // timestamp
            QS_SIG_PRE_(e->sig);   // the signal of this event
            QS_OBJ_PRE_(this);     // this queue object
            QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
            QS_EQC_PRE_(nFree);    // # free entries
            QS_EQC_PRE_(margin);   // margin requested
        QS_END_PRE_()

        status = false; // event not posted
    }

    QF_MEM_APP();
    QF_CRIT_EXIT();

    return status;
}

//${QF::QEQueue::postLIFO} ...................................................
void QEQueue::postLIFO(
    QEvt const * const e,
    std::uint_fast8_t const qs_id) noexcept
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    QEQueueCtr nFree = m_nFree; // get volatile into temporary

    Q_REQUIRE_INCRIT(300, nFree != 0U);

    if (e->getPoolId_() != 0U) { // is it a mutable event?
        QEvt_refCtr_inc_(e); // increment the reference counter
    }

    --nFree; // one free entry just used up
    m_nFree = nFree; // update the original
    if (m_nMin > nFree) {
        m_nMin = nFree; // update minimum so far
    }

    QS_BEGIN_PRE_(QS_QF_EQUEUE_POST_LIFO, qs_id)
        QS_TIME_PRE_();         // timestamp
        QS_SIG_PRE_(e->sig);    // the signal of this event
        QS_OBJ_PRE_(this);      // this queue object
        QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
        QS_EQC_PRE_(nFree);     // # free entries
        QS_EQC_PRE_(m_nMin);    // min # free entries
    QS_END_PRE_()

    QEvt const * const frontEvt = m_frontEvt; // read into temporary
    m_frontEvt = e; // deliver event directly to the front of the queue

    if (frontEvt != nullptr) { // was the queue not empty?
        m_tail = (m_tail + 1U);
        if (m_tail == m_end) { // need to wrap the tail?
            m_tail = 0U; // wrap around
        }
        m_ring[m_tail] = frontEvt; // buffer the old front evt
    }

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

//${QF::QEQueue::get} ........................................................
QEvt const * QEQueue::get(std::uint_fast8_t const qs_id) noexcept {
    #ifndef Q_SPY
    Q_UNUSED_PAR(qs_id);
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    QEvt const * const e  = m_frontEvt; // always remove evt from the front

    if (e != nullptr) { // was the queue not empty?
        QEQueueCtr const nFree = m_nFree + 1U;
        m_nFree = nFree;  // upate the # free

        // any events in the the ring buffer?
        if (nFree <= m_end) {
            m_frontEvt = m_ring[m_tail]; // remove from the tail
            if (m_tail == 0U) { // need to wrap?
                m_tail = m_end; // wrap around
            }
            m_tail = (m_tail - 1U);

            QS_BEGIN_PRE_(QS_QF_EQUEUE_GET, qs_id)
                QS_TIME_PRE_();      // timestamp
                QS_SIG_PRE_(e->sig); // the signal of this event
                QS_OBJ_PRE_(this);   // this queue object
                QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
                QS_EQC_PRE_(nFree);  // # free entries
            QS_END_PRE_()
        }
        else {
            m_frontEvt = nullptr; // queue becomes empty

            // all entries in the queue must be free (+1 for fronEvt)
            Q_ASSERT_INCRIT(410, nFree == (m_end + 1U));

            QS_BEGIN_PRE_(QS_QF_EQUEUE_GET_LAST, qs_id)
                QS_TIME_PRE_();      // timestamp
                QS_SIG_PRE_(e->sig); // the signal of this event
                QS_OBJ_PRE_(this);   // this queue object
                QS_2U8_PRE_(e->getPoolId_(), e->refCtr_); // poolId & refCtr
            QS_END_PRE_()
        }
    }

    QF_MEM_APP();
    QF_CRIT_EXIT();

    return e;
}

} // namespace QP
//$enddef${QF::QEQueue} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$file${src::qf::qf_qmact.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qf_qmact.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qf_qmact.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

// unnamed namespace for local definitions with internal linkage
namespace {
//Q_DEFINE_THIS_MODULE("qf_qmact")
} // unnamed namespace

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QMActive} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QMActive} ............................................................

//${QF::QMActive::QMActive} ..................................................
QMActive::QMActive(QStateHandler const initial) noexcept
  : QActive(initial)
{
    m_state.obj = reinterpret_cast<QMsm *>(this)->topQMState();
    m_temp.fun  = initial;
}

} // namespace QP
//$enddef${QF::QMActive} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$file${src::qf::qf_time.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qf::qf_time.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qf::qf_time.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qp_port.hpp"      // QP port
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem
#ifdef Q_SPY                // QS software tracing enabled?
    #include "qs_port.hpp"  // QS port
    #include "qs_pkg.hpp"   // QS facilities for pre-defined trace records
#else
    #include "qs_dummy.hpp" // disable the QS software tracing
#endif // Q_SPY

// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_MODULE("qf_time")
} // unnamed namespace

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QF::QTimeEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QF::QTimeEvt} ............................................................
QTimeEvt QTimeEvt::timeEvtHead_[QF_MAX_TICK_RATE];

//${QF::QTimeEvt::QTimeEvt} ..................................................
QTimeEvt::QTimeEvt(
    QActive * const act,
    QSignal const sig,
    std::uint_fast8_t const tickRate) noexcept
 :
    QEvt(sig),
    m_next(nullptr),
    m_act(act),
    m_ctr(0U),
    m_interval(0U)
{
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    Q_REQUIRE_INCRIT(300, (sig != 0U)
        && (tickRate < QF_MAX_TICK_RATE));
    QF_CRIT_EXIT();

    // The refCtr_ attribute is not used in time events, so it is
    // reused to hold the tickRate as well as other information
    refCtr_ = static_cast<std::uint8_t>(tickRate);
}

//${QF::QTimeEvt::armX} ......................................................
void QTimeEvt::armX(
    QTimeEvtCtr const nTicks,
    QTimeEvtCtr const interval) noexcept
{
    std::uint8_t const tickRate = refCtr_ & TE_TICK_RATE;
    QTimeEvtCtr const ctr = m_ctr;
    #ifdef Q_SPY
    std::uint_fast8_t const qs_id =
         static_cast<QActive const *>(m_act)->m_prio;
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(400, (m_act != nullptr)
        && (ctr == 0U)
        && (nTicks != 0U)
        && (tickRate < static_cast<std::uint8_t>(QF_MAX_TICK_RATE))
        && (sig >= static_cast<QSignal>(Q_USER_SIG)));
    #ifdef Q_UNSAFE
    Q_UNUSED_PAR(ctr);
    #endif

    m_ctr = nTicks;
    m_interval = interval;

    // is the time event unlinked?
    // NOTE: For the duration of a single clock tick of the specified tick
    // rate a time event can be disarmed and yet still linked into the list
    // because un-linking is performed exclusively in the QF_tickX() function.
    if (static_cast<std::uint_fast8_t>(
           static_cast<std::uint_fast8_t>(refCtr_) & TE_IS_LINKED) == 0U)
    {
        // mark as linked
        refCtr_ = static_cast<std::uint8_t>(refCtr_ | TE_IS_LINKED);

        // The time event is initially inserted into the separate
        // "freshly armed" list based on timeEvtHead_[tickRate].act.
        // Only later, inside QTimeEvt::tick(), the "freshly armed"
        // list is appended to the main list of armed time events based on
        // timeEvtHead_[tickRate].next. Again, this is to keep any
        // changes to the main list exclusively inside QTimeEvt::tick().
        m_next = timeEvtHead_[tickRate].toTimeEvt();
        timeEvtHead_[tickRate].m_act = this;
    }

    QS_BEGIN_PRE_(QS_QF_TIMEEVT_ARM, qs_id)
        QS_TIME_PRE_();        // timestamp
        QS_OBJ_PRE_(this);     // this time event object
        QS_OBJ_PRE_(m_act);    // the active object
        QS_TEC_PRE_(nTicks);   // the # ticks
        QS_TEC_PRE_(interval); // the interval
        QS_U8_PRE_(tickRate);  // tick rate
    QS_END_PRE_()

    QF_MEM_APP();
    QF_CRIT_EXIT();
}

//${QF::QTimeEvt::disarm} ....................................................
bool QTimeEvt::disarm() noexcept {
    #ifdef Q_SPY
    std::uint_fast8_t const qs_id = static_cast<QActive *>(m_act)->m_prio;
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    // is the time event actually armed?
    bool wasArmed;
    if (m_ctr != 0U) {
        wasArmed = true;
        refCtr_ = static_cast<std::uint8_t>(refCtr_ | TE_WAS_DISARMED);

        QS_BEGIN_PRE_(QS_QF_TIMEEVT_DISARM, qs_id)
            QS_TIME_PRE_();            // timestamp
            QS_OBJ_PRE_(this);         // this time event object
            QS_OBJ_PRE_(m_act);        // the target AO
            QS_TEC_PRE_(m_ctr);        // the # ticks
            QS_TEC_PRE_(m_interval);   // the interval
            QS_U8_PRE_(refCtr_& TE_TICK_RATE); // tick rate
        QS_END_PRE_()

        m_ctr = 0U; // schedule removal from the list
    }
    else { // the time event was already disarmed automatically
        wasArmed = false;
        refCtr_ = static_cast<std::uint8_t>(refCtr_
            & static_cast<std::uint8_t>(~TE_WAS_DISARMED));

        QS_BEGIN_PRE_(QS_QF_TIMEEVT_DISARM_ATTEMPT, qs_id)
            QS_TIME_PRE_();            // timestamp
            QS_OBJ_PRE_(this);         // this time event object
            QS_OBJ_PRE_(m_act);        // the target AO
            QS_U8_PRE_(refCtr_& TE_TICK_RATE); // tick rate
        QS_END_PRE_()
    }

    QF_MEM_APP();
    QF_CRIT_EXIT();

    return wasArmed;
}

//${QF::QTimeEvt::rearm} .....................................................
bool QTimeEvt::rearm(QTimeEvtCtr const nTicks) noexcept {
    std::uint8_t const tickRate = refCtr_ & TE_TICK_RATE;

    #ifdef Q_SPY
    std::uint_fast8_t const qs_id = static_cast<QActive *>(m_act)->m_prio;
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(600, (m_act != nullptr)
        && (tickRate < static_cast<std::uint8_t>(QF_MAX_TICK_RATE))
        && (nTicks != 0U)
        && (sig >= static_cast<QSignal>(Q_USER_SIG)));

    // is the time evt not running?
    bool wasArmed;
    if (m_ctr == 0U) {
        wasArmed = false;

        // NOTE: For a duration of a single clock tick of the specified
        // tick rate a time event can be disarmed and yet still linked into
        // the list, because unlinking is performed exclusively in the
        // QTimeEvt::tickX() function.

        // is the time event unlinked?
        if (static_cast<std::uint8_t>(refCtr_ & TE_IS_LINKED) == 0U) {
            // mark as linked
            refCtr_ = static_cast<std::uint8_t>(refCtr_ | TE_IS_LINKED);

            // The time event is initially inserted into the separate
            // "freshly armed" list based on timeEvtHead_[tickRate].act.
            // Only later, inside QTimeEvt::tick(), the "freshly armed"
            // list is appended to the main list of armed time events based on
            // timeEvtHead_[tickRate].next. Again, this is to keep any
            // changes to the main list exclusively inside QTimeEvt::tick().
            m_next = timeEvtHead_[tickRate].toTimeEvt();
            timeEvtHead_[tickRate].m_act = this;
        }
    }
    else { // the time event was armed
        wasArmed = true;
    }
    m_ctr = nTicks; // re-load the tick counter (shift the phasing)

    QS_BEGIN_PRE_(QS_QF_TIMEEVT_REARM, qs_id)
        QS_TIME_PRE_();            // timestamp
        QS_OBJ_PRE_(this);         // this time event object
        QS_OBJ_PRE_(m_act);        // the target AO
        QS_TEC_PRE_(m_ctr);        // the # ticks
        QS_TEC_PRE_(m_interval);   // the interval
        QS_2U8_PRE_(tickRate, (wasArmed ? 1U : 0U));
    QS_END_PRE_()

    QF_MEM_APP();
    QF_CRIT_EXIT();

    return wasArmed;
}

//${QF::QTimeEvt::wasDisarmed} ...............................................
bool QTimeEvt::wasDisarmed() noexcept {
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    std::uint8_t const isDisarmed = refCtr_ & TE_WAS_DISARMED;
    refCtr_ = static_cast<std::uint8_t>(refCtr_ | TE_WAS_DISARMED);

    QF_MEM_APP();
    QF_CRIT_EXIT();

    return isDisarmed != 0U;
}

//${QF::QTimeEvt::tick} ......................................................
void QTimeEvt::tick(
    std::uint_fast8_t const tickRate,
    void const * const sender) noexcept
{
    #ifndef Q_SPY
    Q_UNUSED_PAR(sender);
    #endif

    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    QF_MEM_SYS();

    Q_REQUIRE_INCRIT(100, tickRate < Q_DIM(timeEvtHead_));

    QTimeEvt *prev = &timeEvtHead_[tickRate];

    QS_BEGIN_PRE_(QS_QF_TICK, 0U)
        prev->m_ctr = (prev->m_ctr + 1U);
        QS_TEC_PRE_(prev->m_ctr); // tick ctr
        QS_U8_PRE_(tickRate);     // tick rate
    QS_END_PRE_()

    // scan the linked-list of time events at this rate...
    std::uint_fast8_t limit = 2U*QF_MAX_ACTIVE; // iteration hard limit
    for (; limit > 0U; --limit) {
        QTimeEvt *e = prev->m_next; // advance down the time evt. list

        if (e == nullptr) { // end of the list?

            // any new time events armed since the last run of tick()?
            if (timeEvtHead_[tickRate].m_act != nullptr) {

                // sanity check
                Q_ASSERT_INCRIT(110, prev != nullptr);
                prev->m_next = timeEvtHead_[tickRate].toTimeEvt();
                timeEvtHead_[tickRate].m_act = nullptr;
                e = prev->m_next; // switch to the new list
            }
            else { // all currently armed time events are processed
                break; // terminate the for-loop
            }
        }

        // the time event 'e' must be valid
        Q_ASSERT_INCRIT(112, QEvt::verify_(e));

        if (e->m_ctr == 0U) { // time event scheduled for removal?
            prev->m_next = e->m_next;
            // mark time event 'e' as NOT linked
            e->refCtr_ = static_cast<std::uint8_t>(e->refCtr_
                & static_cast<std::uint8_t>(~TE_IS_LINKED));
            // do NOT advance the prev pointer
            QF_MEM_APP();
            QF_CRIT_EXIT(); // exit crit. section to reduce latency

            // NOTE: prevent merging critical sections
            // In some QF ports the critical section exit takes effect only
            // on the next machine instruction. If the next instruction is
            // another entry to a critical section, the critical section
            // might not be really exited, but rather the two adjacent
            // critical sections would be MERGED. The QF_CRIT_EXIT_NOP()
            // macro contains minimal code required to prevent such merging
            // of critical sections in QF ports, in which it can occur.
            QF_CRIT_EXIT_NOP();
        }
        else {
            e->m_ctr = (e->m_ctr - 1U);

            if (e->m_ctr == 0U) { // is time evt about to expire?
                QActive * const act = e->toActive();

                if (e->m_interval != 0U) { // periodic time evt?
                    e->m_ctr = e->m_interval; // rearm the time event
                    prev = e; // advance to this time event
                }
                else { // one-shot time event: automatically disarm
                    prev->m_next = e->m_next;

                    // mark time event 'e' as NOT linked
                    e->refCtr_ = static_cast<std::uint8_t>(e->refCtr_
                        & static_cast<std::uint8_t>(~TE_IS_LINKED));
                    // do NOT advance the prev pointer

                    QS_BEGIN_PRE_(QS_QF_TIMEEVT_AUTO_DISARM, act->m_prio)
                        QS_OBJ_PRE_(e);        // this time event object
                        QS_OBJ_PRE_(act);      // the target AO
                        QS_U8_PRE_(tickRate);  // tick rate
                    QS_END_PRE_()
                }

                QS_BEGIN_PRE_(QS_QF_TIMEEVT_POST, act->m_prio)
                    QS_TIME_PRE_();            // timestamp
                    QS_OBJ_PRE_(e);            // the time event object
                    QS_SIG_PRE_(e->sig);       // signal of this time event
                    QS_OBJ_PRE_(act);          // the target AO
                    QS_U8_PRE_(tickRate);      // tick rate
                QS_END_PRE_()

    #ifdef QXK_HPP_
                if (e->sig < Q_USER_SIG) {
                    QXThread::timeout_(act);
                }
                else {
                    QF_MEM_APP();
                    QF_CRIT_EXIT(); // exit crit. section before posting

                    // act->POST() asserts if the queue overflows
                    act->POST(e, sender);
                }
    #else
                QF_MEM_APP();
                QF_CRIT_EXIT(); // exit crit. section before posting

                // act->POST() asserts if the queue overflows
                act->POST(e, sender);
    #endif
            }
            else {
                prev = e; // advance to this time event

                QF_MEM_APP();
                QF_CRIT_EXIT(); // exit crit. section to reduce latency

                // prevent merging critical sections, see NOTE above
                QF_CRIT_EXIT_NOP();
            }
        }
        QF_CRIT_ENTRY(); // re-enter crit. section to continue the loop
        QF_MEM_SYS();
    }

    Q_ENSURE_INCRIT(190, limit > 0U);
    QF_MEM_APP();
    QF_CRIT_EXIT();
}

//${QF::QTimeEvt::noActive} ..................................................
bool QTimeEvt::noActive(std::uint_fast8_t const tickRate) noexcept {
    QF_CRIT_STAT
    QF_CRIT_ENTRY();
    Q_REQUIRE_INCRIT(800, tickRate < QF_MAX_TICK_RATE);
    QF_CRIT_EXIT();

    bool inactive;
    if (timeEvtHead_[tickRate].m_next != nullptr) {
        inactive = false;
    }
    else if (timeEvtHead_[tickRate].m_act != nullptr) {
        inactive = false;
    }
    else {
        inactive = true;
    }
    return inactive;
}

//${QF::QTimeEvt::QTimeEvt} ..................................................
QTimeEvt::QTimeEvt() noexcept
 :
    QEvt(0U),
    m_next(nullptr),
    m_act(nullptr),
    m_ctr(0U),
    m_interval(0U)
{
    // The refCtr_ attribute is not used in time events, so it is
    // reused to hold the tickRate as well as other information
    refCtr_ = 0U; // default rate 0
}

} // namespace QP
//$enddef${QF::QTimeEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
